use crate::{lexer, ast};
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, lexer::Tok, lexer::LexError>>);

extern {
    type Location = usize;
    type Error = lexer::LexError;

    enum lexer::Tok {
        "identifier" => lexer::Tok::Identifier(<String>),
        "string" => lexer::Tok::String(<String>),
        "number" => lexer::Tok::Number(<usize>),
        "type" => lexer::Tok::Type,
        "=" => lexer::Tok::Equals,
        "==" => lexer::Tok::DoubleEquals,
        "let" => lexer::Tok::Let,
        "+" => lexer::Tok::Plus,
        "-" => lexer::Tok::Minus,
        "*" => lexer::Tok::Asterisk,
        "/" => lexer::Tok::Slash,
        "{" => lexer::Tok::LBrace,
        "}" => lexer::Tok::RBrace,
        "(" => lexer::Tok::LParen,
        ")" => lexer::Tok::RParen,
        "[" => lexer::Tok::LBracket,
        "]" => lexer::Tok::RBracket,
        ":" => lexer::Tok::Colon,
        ";" => lexer::Tok::Semicolon,
        "," => lexer::Tok::Comma,
        "->" => lexer::Tok::ThinArrow,
        "=>" => lexer::Tok::ThickArrow,
        "fn" => lexer::Tok::Fn,
        "!" => lexer::Tok::Not,
        "!=" => lexer::Tok::NotEquals,
        "true" => lexer::Tok::True,
        "false" => lexer::Tok::False,
        "&&" => lexer::Tok::And,
        "||" => lexer::Tok::Or,
        "_" => lexer::Tok::Underscore,
        "." => lexer::Tok::Period,
        ".." => lexer::Tok::DoublePeriod,
        "mut" => lexer::Tok::Mut,
        "if" => lexer::Tok::If,
        "else" => lexer::Tok::Else,
        "%" => lexer::Tok::Percent,
        "%{" => lexer::Tok::PercentLBrace,
        "for" => lexer::Tok::For,
        "in" => lexer::Tok::In,
        "while" => lexer::Tok::While,
        "break" => lexer::Tok::Break,
        "continue" => lexer::Tok::Continue,
    }
}

Identifier: String = "identifier";

Ty: ast::Type = {
    "identifier" => ast::Type::Type(<>),
    "{" <ty_fields:(<TyField> ",")*> "}" => ast::Type::Record(ty_fields),
    "{" <ty_fields:(<TyField> ",")*> <last:TyField> "}" => {
        let mut ty_fields = ty_fields;
        ty_fields.push(last);
        ast::Type::Record(ty_fields)
    },
    "[" <ty:Ty> ";" <len:"number"> "]" => ast::Type::Array(Box::new(ty), len),
};

TyField: ast::TypeField = {
    <id:"identifier"> ":" <ty:Ty> => ast::TypeField { <> }
};

TypeDecl: ast::TypeDecl =
    "type" <type_id:"identifier"> "=" <ty:Ty> =>
        ast::TypeDecl { <> };

Let: ast::Let<ast::Expr> = {
   "let" "_" <ty:(":" <Ty>)?> "=" <expr:ExprType> => ast::Let {
        pattern: ast::Pattern::Wildcard,
        mutable: false,
        ty: ty,
        expr: expr,
    },
   "let" <mutable:"mut"?> <id:"identifier"> <ty:(":" <Ty>)?> "=" <expr:ExprType> => ast::Let {
        pattern: ast::Pattern::String(id),
        mutable: mutable.is_some(),
        ty: ty,
        expr: expr,
    },
};

Assign: ast::Assign<ast::Expr> = {
   <lval:LVal> "=" <expr:ExprType> => ast::Assign { <> },
};

FnDecl: ast::FnDecl<ast::Expr> = {
    "fn" <id:"identifier"> "(" <type_fields:(<TyField> ",")*> ")"
        <return_type:("->" <Ty>)?> "=" <body:ExprType> ";" => {
        ast::FnDecl {
            id,
            type_fields,
            return_type,
            body,
        }
    },
    "fn" <id:"identifier"> "(" <type_fields:(<TyField> ",")*> <last:TyField> ")"
        <return_type:("->" <Ty>)?> "=" <body:ExprType> ";" => {
        let mut type_fields = type_fields;
        type_fields.push(last);
        ast::FnDecl {
            id,
            type_fields,
            return_type,
            body,
        }
    }
};

Decl: ast::Decl<ast::Expr> = {
    <l:@L> <ty:DeclType> <r:@R> => ast::Decl { ty, span: ast::Span { l, r } }
};

DeclType: ast::DeclType<ast::Expr> = {
    <TypeDecl> ";" => ast::DeclType::Type(<>),
    <FnDecl> => ast::DeclType::Fn(<>),
    ! => {
        errors.push(<>);
        ast::DeclType::Error
    },
};

ExprTypeOrLetOrAssign: ast::Expr = {
    Range,
    <l:@L> <expr:Let> <r:@R> => ast::Expr::new(ast::ExprType::Let(Box::new(expr)), (l, r)),
    <l:@L> <expr:Assign> <r:@R> => ast::Expr::new(ast::ExprType::Assign(Box::new(expr)), (l, r)),
}

Range: ast::Expr = {
    <l:ExprType> ".." <r:ExprType> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Range(Box::new(l), Box::new(r)), (lspan.l, rspan.r))
    },
    ExprType,
};

ExprType: ast::Expr = {
    <l:ExprType> "==" <r:OpExpr> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Compare(Box::new(l), ast::CompareOp::Equal, Box::new(r)), (lspan.l, rspan.r))
    },
    OpExpr,
};

OpExpr: ast::Expr = {
    <l:OpExpr> "+" <r:Factor> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Arith(Box::new(l), ast::ArithOp::Add, Box::new(r)), (lspan.l, rspan.r))
    },
    <l:OpExpr> "-" <r:Factor> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Arith(Box::new(l), ast::ArithOp::Sub, Box::new(r)), (lspan.l, rspan.r))
    },
    <l:OpExpr> "||" <r:Factor> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Bool(Box::new(l), ast::BoolOp::Or, Box::new(r)), (lspan.l, rspan.r))
    },
    Factor,
};

ExprTypeSeq: ast::ExprType<ast::Expr> = {
    "{" <l:@L> <r:@R> "}" => ast::ExprType::Seq(vec![ast::Expr::new(ast::ExprType::Unit, (l, r))], true),
    "{" <exprs:(<ExprTypeOrLetOrAssign> ";")*> <last:ExprTypeOrLetOrAssign> <last_semi:";"?> "}" => {
        let mut exprs = exprs;
        exprs.push(last);
        ast::ExprType::Seq(exprs, last_semi.is_none())
    }
};

Factor: ast::Expr = {
    <l:Factor> "*" <r:TermOrNeg> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Arith(Box::new(l), ast::ArithOp::Mul, Box::new(r)), (lspan.l, rspan.r))
    },
    <l:Factor> "/" <r:TermOrNeg> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Arith(Box::new(l), ast::ArithOp::Div, Box::new(r)), (lspan.l, rspan.r))
    },
    <l:Factor> "&&" <r:TermOrNeg> => {
        let lspan = l.span;
        let rspan = r.span;
        ast::Expr::new(ast::ExprType::Bool(Box::new(l), ast::BoolOp::And, Box::new(r)), (lspan.l, rspan.r))
    },
    TermOrNeg,
};

TermOrNeg: ast::Expr = {
    Term,
    <l:@L> "-" <term:Term> => {
        let rspan = term.span;
        ast::Expr::new(ast::ExprType::Neg(Box::new(term)), (l, rspan.r))
    },
    <l:@L> "!" <term:Term> => {
        let rspan = term.span;
        ast::Expr::new(ast::ExprType::Not(Box::new(term)), (l, rspan.r))
    },
};

Term: ast::Expr = {
    <l:@L> <n:"number"> <r:@R> => ast::Expr::new(ast::ExprType::Number(n), (l, r)),
    <l:@L> <s:"string"> <r:@R> => ast::Expr::new(ast::ExprType::String(s), (l, r)),
    <l:@L> "true" <r:@R> => ast::Expr::new(ast::ExprType::BoolLiteral(true), (l, r)),
    <l:@L> "false" <r:@R> => ast::Expr::new(ast::ExprType::BoolLiteral(false), (l, r)),
    <l:@L> "continue" <r:@R> => ast::Expr::new(ast::ExprType::Continue, (l, r)),
    <l:@L> "break" <r:@R> => ast::Expr::new(ast::ExprType::Break, (l, r)),
    <l:@L> "(" <expr:ExprType> ")" <r:@R> => ast::Expr::new(expr.ty, (l, r)),
    <l:@L> "(" ")" <r:@R> => ast::Expr::new(ast::ExprType::Unit, (l, r)),
    <l:@L> <expr:LVal> <r:@R> => ast::Expr::new(ast::ExprType::LVal(Box::new(expr)), (l, r)),
    <l:@L> <expr:FnCall> <r:@R> => ast::Expr::new(ast::ExprType::FnCall(Box::new(expr)), (l, r)),
    <l:@L> <expr:Array> <r:@R> => ast::Expr::new(ast::ExprType::Array(Box::new(expr)), (l, r)),
    <l:@L> <expr:Record> <r:@R> => ast::Expr::new(ast::ExprType::Record(Box::new(expr)), (l, r)),
    <l:@L> <expr:If> <r:@R> => ast::Expr::new(ast::ExprType::If(Box::new(expr)), (l, r)),
    <l:@L> <expr:For> <r:@R> => ast::Expr::new(ast::ExprType::For(Box::new(expr)), (l, r)),
    <l:@L> <expr:While> <r:@R> => ast::Expr::new(ast::ExprType::While(Box::new(expr)), (l, r)),
    <l:@L> <expr:ExprTypeSeq> <r:@R> => ast::Expr::new(expr, (l, r)),
};

LVal: ast::LVal<ast::Expr> = {
    "identifier" => ast::LVal::Simple(<>),
    <val:LVal> "." <field:"identifier"> => ast::LVal::Field(Box::new(val), field),
    <val:LVal> "[" <subscript:ExprType> "]" => ast::LVal::Subscript(Box::new(val), subscript),
};

FnCall: ast::FnCall<ast::Expr> = {
    <id:"identifier"> "(" <args:(<ExprType> ",")*> ")" => ast::FnCall { <> },
    <id:"identifier"> "(" <args:(<ExprType> ",")*> <last:ExprType> ")" => {
        let mut args = args;
        args.push(last);
        ast::FnCall { id, args }
    }
};

Record: ast::Record<ast::Expr> = {
    <id:"identifier"> "%{" <field_assigns:(<FieldAssign> ",")*> "}" => ast::Record { <> },
    <id:"identifier"> "%{" <field_assigns:(<FieldAssign> ",")*> <last:FieldAssign> "}" => {
        let mut field_assigns = field_assigns;
        field_assigns.push(last);
        ast::Record {
            id,
            field_assigns,
        }
    }
};

FieldAssign: ast::FieldAssign<ast::Expr> = {
    <id:"identifier"> ":" <expr:ExprType> => ast::FieldAssign { <> }
};

Array: ast::Array<ast::Expr> = {
    "[" <initial_value:ExprType> ";" <len:ExprType> "]" => ast::Array { <> }
};

If: ast::If<ast::Expr> = {
    "if" <cond:ExprType> <l:@L> <then_expr:ExprTypeSeq> <r:@R> => ast::If {
        cond,
        then_expr: ast::Expr::new(then_expr, (l, r)),
        else_expr: None,
    },
    "if" <cond:ExprType> <tl:@L> <then_expr:ExprTypeSeq> <tr:@R> "else" <el:@L> <else_expr:ExprTypeSeq> <er:@R> => ast::If {
        cond,
        then_expr: ast::Expr::new(then_expr, (tl, tr)),
        else_expr: Some(ast::Expr::new(else_expr, (el, er))),
    },
    "if" <cond:ExprType> <tl:@L> <then_expr:ExprTypeSeq> <tr:@R> "else" <el:@L> <else_if:If> <er:@R> => ast::If {
        cond,
        then_expr: ast::Expr::new(then_expr, (tl, tr)),
        else_expr: Some(ast::Expr::new(ast::ExprType::If(Box::new(else_if)), (el, er))),
    },
};

For: ast::For<ast::Expr> = {
    "for" <index:"identifier"> "in" <range:Range> <l:@L> <body:ExprTypeSeq> <r:@R> => ast::For {
        index,
        range,
        body: ast::Expr::new(body, (l, r)),
    }
};

While: ast::While<ast::Expr> = {
    "while" <cond:ExprType> <l:@L> <body:ExprTypeSeq> <r:@R> => ast::While {
        cond,
        body: ast::Expr::new(body, (l, r)),
    }
};

pub Program: Vec<ast::Decl<ast::Expr>> = <Decl*>;
